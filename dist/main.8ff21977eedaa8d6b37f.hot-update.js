/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdateitkVtkViewer"]("main",{

/***/ "./src/index.js?c170":
/*!******************************!*\
  !*** ./src/index-exposed.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var ___EXPOSE_LOADER_IMPORT___ = __webpack_require__(/*! -!./index.js */ \"./src/index.js?b635\");\nvar ___EXPOSE_LOADER_GET_GLOBAL_THIS___ = __webpack_require__(/*! ../node_modules/expose-loader/dist/runtime/getGlobalThis.js */ \"./node_modules/expose-loader/dist/runtime/getGlobalThis.js\");\nvar ___EXPOSE_LOADER_GLOBAL_THIS___ = ___EXPOSE_LOADER_GET_GLOBAL_THIS___;\nif (typeof ___EXPOSE_LOADER_GLOBAL_THIS___[\"itkVtkViewer\"] === 'undefined') ___EXPOSE_LOADER_GLOBAL_THIS___[\"itkVtkViewer\"] = ___EXPOSE_LOADER_IMPORT___;else throw new Error('[exposes-loader] The \"itkVtkViewer\" value exists in the global scope, it may not be safe to overwrite it, use the \"override\" option');\nmodule.exports = ___EXPOSE_LOADER_IMPORT___;\n\n//# sourceURL=webpack://itkVtkViewer/./src/index.js?");

/***/ }),

/***/ "./src/createViewer.js":
/*!*****************************!*\
  !*** ./src/createViewer.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\");\n/* harmony import */ var core_js_actual_structured_clone__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/actual/structured-clone */ \"./node_modules/core-js/actual/structured-clone.js\");\n/* harmony import */ var core_js_actual_structured_clone__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_actual_structured_clone__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/mat4.js\");\n/* harmony import */ var _xstate_inspect__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @xstate/inspect */ \"./node_modules/@xstate/inspect/es/browser.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! xstate */ \"./node_modules/xstate/es/interpreter.js\");\n/* harmony import */ var vtk_js_Sources_Proxy_Core_ProxyManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vtk.js/Sources/Proxy/Core/ProxyManager */ \"./node_modules/vtk.js/Sources/Proxy/Core/ProxyManager/index.js\");\n/* harmony import */ var css_element_queries_src_ResizeSensor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! css-element-queries/src/ResizeSensor */ \"./node_modules/css-element-queries/src/ResizeSensor.js\");\n/* harmony import */ var css_element_queries_src_ResizeSensor__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(css_element_queries_src_ResizeSensor__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _Rendering_VTKJS_proxyManagerConfiguration__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Rendering/VTKJS/proxyManagerConfiguration */ \"./src/Rendering/VTKJS/proxyManagerConfiguration.js\");\n/* harmony import */ var _UserInterface__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./UserInterface */ \"./src/UserInterface/index.js\");\n/* harmony import */ var _UI_addKeyboardShortcuts__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./UI/addKeyboardShortcuts */ \"./src/UI/addKeyboardShortcuts.js\");\n/* harmony import */ var _UserInterface_rgb2hex__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./UserInterface/rgb2hex */ \"./src/UserInterface/rgb2hex.js\");\n/* harmony import */ var _UserInterface_hex2rgb__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./UserInterface/hex2rgb */ \"./src/UserInterface/hex2rgb.js\");\n/* harmony import */ var _ViewerStore__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ViewerStore */ \"./src/ViewerStore.js\");\n/* harmony import */ var _IO_toMultiscaleSpatialImage__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./IO/toMultiscaleSpatialImage */ \"./src/IO/toMultiscaleSpatialImage.js\");\n/* harmony import */ var _IO_MultiscaleSpatialImage__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./IO/MultiscaleSpatialImage */ \"./src/IO/MultiscaleSpatialImage.js\");\n/* harmony import */ var _viewerMachineOptions__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./viewerMachineOptions */ \"./src/viewerMachineOptions.js\");\n/* harmony import */ var _createViewerMachine__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./createViewerMachine */ \"./src/createViewerMachine.js\");\n/* harmony import */ var _Context_ViewerMachineContext__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./Context/ViewerMachineContext */ \"./src/Context/ViewerMachineContext.js\");\n/* harmony import */ var _Rendering_VTKJS_Main_croppingPlanes__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./Rendering/VTKJS/Main/croppingPlanes */ \"./src/Rendering/VTKJS/Main/croppingPlanes.js\");\n/* harmony import */ var mobx__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! mobx */ \"./node_modules/mobx/lib/mobx.module.js\");\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! p-queue */ \"./node_modules/p-queue/dist/index.js\");\n\n\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nif (!('structuredClone' in window)) {\n  // Attach the polyfill as a Global function\n  window.structuredClone = (core_js_actual_structured_clone__WEBPACK_IMPORTED_MODULE_3___default());\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar createViewer = /*#__PURE__*/function () {\n  var _ref2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__[\"default\"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(rootContainer, _ref) {\n    var image, _ref$imageName, imageName, labelImage, fixedImage, compare, geometries, pointSets, _ref$use2D, use2D, _ref$rotate, rotate, config, gradientOpacity, proxyManager, store, publicAPI, debug, eventEmitter, eventEmitterCallback, context, options, uiMachineOptions, loadedUIMachineOptions, imageMultiscale, labelImageMultiscale, imageOrLabelImage, machine, service, resizeSensor, eventNames, apiFunctionQueue, queueApi;\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) switch (_context5.prev = _context5.next) {\n        case 0:\n          eventEmitterCallback = function _eventEmitterCallback(context /*, event*/) {\n            return function (callback, onReceive) {\n              onReceive(function (event) {\n                switch (event.type) {\n                  case 'SET_BACKGROUND_COLOR':\n                    eventEmitter.emit('backgroundColorChanged', event.data);\n                    break;\n                  case 'TOGGLE_BACKGROUND_COLOR':\n                    eventEmitter.emit('backgroundColorChanged', context.main.backgroundColor);\n                    break;\n                  case 'TOGGLE_FULLSCREEN':\n                    eventEmitter.emit('toggleFullscreen', publicAPI.getFullscreenEnabled());\n                    break;\n                  case 'TOGGLE_UI_COLLAPSED':\n                    eventEmitter.emit('toggleUICollapsed', event.data);\n                    break;\n                  case 'TOGGLE_ROTATE':\n                    eventEmitter.emit('toggleRotate', event.data);\n                    break;\n                  case 'TOGGLE_ANNOTATIONS':\n                    eventEmitter.emit('toggleAnnotations', publicAPI.getAnnotationsEnabled());\n                    break;\n                  case 'TOGGLE_AXES':\n                    eventEmitter.emit('toggleAxes', event.data);\n                    break;\n                  case 'TOGGLE_IMAGE_INTERPOLATION':\n                    eventEmitter.emit('toggleImageInterpolation', event.data);\n                    break;\n                  case 'TOGGLE_CROPPING_PLANES':\n                    eventEmitter.emit('toggleCroppingPlanes', event.data);\n                    break;\n                  case 'RESET_CROPPING_PLANES':\n                    eventEmitter.emit('resetCroppingPlanes', event.data);\n                    break;\n                  case 'CROPPING_PLANES_CHANGED':\n                    eventEmitter.emit('croppingPlanesChanged', event.data);\n                    break;\n                  case 'VIEW_MODE_CHANGED':\n                    eventEmitter.emit('viewModeChanged', event.data);\n                    break;\n                  case 'TOGGLE_LAYER_VISIBILITY':\n                    eventEmitter.emit('toggleLayerVisibility', event.data);\n                    break;\n                  case 'RENDERED_IMAGE_ASSIGNED':\n                    eventEmitter.emit('renderedImageAssigned', event.data);\n                    break;\n                  case 'IMAGE_COMPONENT_VISIBILITY_CHANGED':\n                    eventEmitter.emit('imageVisualizedComponentChanged', event.data);\n                    break;\n                  case 'IMAGE_PIECEWISE_FUNCTION_GAUSSIANS_CHANGED':\n                    eventEmitter.emit('imagePiecewiseFunctionGaussiansChanged', event.data);\n                    break;\n                  case 'IMAGE_PIECEWISE_FUNCTION_POINTS_CHANGED':\n                    eventEmitter.emit('imagePiecewiseFunctionPointsChanged', event.data);\n                    break;\n                  case 'IMAGE_COLOR_RANGE_CHANGED':\n                    eventEmitter.emit('imageColorRangeChanged', event.data);\n                    break;\n                  case 'IMAGE_COLOR_RANGE_BOUNDS_CHANGED':\n                    eventEmitter.emit('imageColorRangeBoundsChanged', event.data);\n                    break;\n                  case 'IMAGE_COLOR_MAP_CHANGED':\n                    eventEmitter.emit('imageColorMapChanged', event.data);\n                    break;\n                  case 'TOGGLE_IMAGE_SHADOW':\n                    eventEmitter.emit('toggleImageShadow', event.data);\n                    break;\n                  case 'IMAGE_GRADIENT_OPACITY_CHANGED':\n                    eventEmitter.emit('imageGradientOpacityChanged', event.data);\n                    break;\n                  case 'IMAGE_GRADIENT_OPACITY_SCALE_CHANGED':\n                    eventEmitter.emit('imageGradientOpacityScaleChanged', event.data);\n                    break;\n                  case 'IMAGE_VOLUME_SAMPLE_DISTANCE_CHANGED':\n                    eventEmitter.emit('imageVolumeSampleDistanceChanged', event.data);\n                    break;\n                  case 'IMAGE_BLEND_MODE_CHANGED':\n                    eventEmitter.emit('imageBlendModeChanged', event.data);\n                    break;\n                  case 'LABEL_IMAGE_LOOKUP_TABLE_CHANGED':\n                    eventEmitter.emit('labelImageLookupTableChanged', event.data);\n                    break;\n                  case 'LABEL_IMAGE_BLEND_CHANGED':\n                    eventEmitter.emit('labelImageBlendChanged', event.data);\n                    break;\n                  case 'LABEL_IMAGE_WEIGHTS_CHANGED':\n                    eventEmitter.emit('labelImageWeightsChanged', event.data);\n                    break;\n                  case 'LABEL_IMAGE_LABEL_NAMES_CHANGED':\n                    eventEmitter.emit('labelImageLabelNamesChanged', event.data);\n                    break;\n                  case 'X_SLICE_CHANGED':\n                    eventEmitter.emit('xSliceChanged', event.data);\n                    break;\n                  case 'Y_SLICE_CHANGED':\n                    eventEmitter.emit('ySliceChanged', event.data);\n                    break;\n                  case 'Z_SLICE_CHANGED':\n                    eventEmitter.emit('zSliceChanged', event.data);\n                    break;\n                  case 'SCREENSHOT_TAKEN':\n                    eventEmitter.emit('screenshotTaken', event.data);\n                    break;\n                  case 'TAKE_SCREENSHOT':\n                    break;\n                  default:\n                    throw new Error(\"Unexpected event type: \".concat(event.type));\n                }\n              });\n            };\n          };\n          image = _ref.image, _ref$imageName = _ref.imageName, imageName = _ref$imageName === void 0 ? undefined : _ref$imageName, labelImage = _ref.labelImage, fixedImage = _ref.fixedImage, compare = _ref.compare, geometries = _ref.geometries, pointSets = _ref.pointSets, _ref$use2D = _ref.use2D, use2D = _ref$use2D === void 0 ? undefined : _ref$use2D, _ref$rotate = _ref.rotate, rotate = _ref$rotate === void 0 ? false : _ref$rotate, config = _ref.config, gradientOpacity = _ref.gradientOpacity;\n          _UserInterface__WEBPACK_IMPORTED_MODULE_7__[\"default\"].emptyContainer(rootContainer);\n          if (_UserInterface__WEBPACK_IMPORTED_MODULE_7__[\"default\"].checkForWebGL(rootContainer)) {\n            _context5.next = 5;\n            break;\n          }\n          throw new Error('WebGL could not be loaded.');\n        case 5:\n          proxyManager = vtk_js_Sources_Proxy_Core_ProxyManager__WEBPACK_IMPORTED_MODULE_4__[\"default\"].newInstance({\n            proxyConfiguration: _Rendering_VTKJS_proxyManagerConfiguration__WEBPACK_IMPORTED_MODULE_6__[\"default\"]\n          });\n          window.addEventListener('resize', proxyManager.resizeAllViews);\n          store = new _ViewerStore__WEBPACK_IMPORTED_MODULE_11__[\"default\"](proxyManager);\n          publicAPI = {};\n          debug = false;\n          if (debug) {\n            //const stateIFrame = document.createElement('iframe')\n            //store.container.style.height = '50%'\n            //stateIFrame.style.height = '50%'\n            //rootContainer.appendChild(stateIFrame)\n            (0,_xstate_inspect__WEBPACK_IMPORTED_MODULE_20__.inspect)({\n              //iframe: stateIFrame,\n              iframe: false\n            });\n          }\n          eventEmitter = store.eventEmitter;\n          context = new _Context_ViewerMachineContext__WEBPACK_IMPORTED_MODULE_16__[\"default\"](config);\n          options = _objectSpread({}, _viewerMachineOptions__WEBPACK_IMPORTED_MODULE_14__[\"default\"]);\n          if (!(context.uiMachineOptions !== 'reference')) {\n            _context5.next = 24;\n            break;\n          }\n          uiMachineOptions = context.uiMachineOptions;\n          if (!uiMachineOptions.href) {\n            _context5.next = 23;\n            break;\n          }\n          _context5.next = 19;\n          return import( /* webpackIgnore: true */\n          uiMachineOptions.href);\n        case 19:\n          loadedUIMachineOptions = _context5.sent;\n          if (uiMachineOptions.export) {\n            options.ui = loadedUIMachineOptions[uiMachineOptions.export];\n          } else {\n            options.ui = loadedUIMachineOptions.default;\n          }\n          _context5.next = 24;\n          break;\n        case 23:\n          if (context.uiMachineOptions === 'pydata-sphinx') {\n            options.ui = {\n              href: 'https://cdn.jsdelivr.net/npm/itk-viewer-bootstrap-ui@0/dist/bootstrapUIMachineOptions.js.es.js',\n              export: 'default'\n            };\n          } else if (context.uiMachineOptions === 'mui') {\n            options.ui = {\n              href: 'https://cdn.jsdelivr.net/npm/itk-viewer-material-ui@0/dist/materialUIMachineOptions.js.es.js',\n              export: 'default'\n            };\n          } else {\n            options.ui = uiMachineOptions;\n          }\n        case 24:\n          _context5.t0 = image;\n          if (!_context5.t0) {\n            _context5.next = 29;\n            break;\n          }\n          _context5.next = 28;\n          return (0,_IO_toMultiscaleSpatialImage__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(image, false, context.maxConcurrency);\n        case 28:\n          _context5.t0 = _context5.sent;\n        case 29:\n          imageMultiscale = _context5.t0;\n          _context5.t1 = labelImage;\n          if (!_context5.t1) {\n            _context5.next = 35;\n            break;\n          }\n          _context5.next = 34;\n          return (0,_IO_toMultiscaleSpatialImage__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(labelImage, true, context.maxConcurrency);\n        case 34:\n          _context5.t1 = _context5.sent;\n        case 35:\n          labelImageMultiscale = _context5.t1;\n          imageOrLabelImage = imageMultiscale || labelImageMultiscale;\n          context.use2D = use2D !== null && use2D !== void 0 ? use2D : Boolean(imageOrLabelImage && imageOrLabelImage.imageType.dimension === 2);\n          context.rootContainer = rootContainer;\n          // Todo: move to viewer machine\n          context.container = store.container;\n          // Todo: move to VTKJS/createRenderer\n          context.itkVtkView = store.itkVtkView;\n          context.proxyManager = store.proxyManager;\n          context.renderWindow = store.renderWindow;\n          context.id = store.id;\n          machine = (0,_createViewerMachine__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(options, context, eventEmitterCallback);\n          service = (0,xstate__WEBPACK_IMPORTED_MODULE_21__.interpret)(machine, {\n            devTools: debug\n          });\n          context.service = service;\n          service.start();\n          (0,mobx__WEBPACK_IMPORTED_MODULE_18__.reaction)(function () {\n            return !!store.geometriesUI.geometries && store.geometriesUI.geometries.slice();\n          }, function (geometries) {\n            if (!geometries || geometries.length === 0) {\n              return;\n            }\n            geometries.forEach(function (geometry, index) {\n              if (store.geometriesUI.sources.length <= index) {\n                var uid = \"GeometrySource\".concat(index);\n                var geometrySource = proxyManager.createProxy('Sources', 'TrivialProducer', {\n                  name: uid\n                });\n                store.geometriesUI.sources.push(geometrySource);\n                store.geometriesUI.sources[index].setInputData(geometry);\n                proxyManager.createRepresentationInAllViews(geometrySource);\n                var geometryRepresentation = proxyManager.getRepresentation(geometrySource, store.itkVtkView);\n                store.geometriesUI.representationProxies.push(geometryRepresentation);\n                (0,_Rendering_VTKJS_Main_croppingPlanes__WEBPACK_IMPORTED_MODULE_17__.addCroppingPlanes)(context, geometryRepresentation);\n              } else {\n                store.geometriesUI.sources[index].setInputData(geometry);\n                store.geometriesUI.representationProxies[index].setVisibility(true);\n              }\n            });\n            (0,_Rendering_VTKJS_Main_croppingPlanes__WEBPACK_IMPORTED_MODULE_17__.updateCroppingParameters)(context);\n            if (geometries.length < store.geometriesUI.representationProxies.length) {\n              var proxiesToDisable = store.geometriesUI.representationProxies.slice(geometries.length);\n              proxiesToDisable.forEach(function (proxy) {\n                proxy.setVisibility(false);\n              });\n            }\n            if (!store.geometriesUI.initialized) {\n              _UserInterface__WEBPACK_IMPORTED_MODULE_7__[\"default\"].createGeometriesUI(store, context.uiContainer);\n            }\n            store.geometriesUI.names = geometries.map(function (geometry, index) {\n              return \"Geometry \".concat(index);\n            });\n            var representations = store.geometriesUI.representations.slice(0, geometries.length);\n            var defaultGeometryRepresentations = new Array(geometries.length);\n            defaultGeometryRepresentations.fill('Surface');\n            representations.concat(defaultGeometryRepresentations.slice(0, geometries.length - representations.length));\n            store.geometriesUI.representations = representations;\n          });\n          store.geometriesUI.geometries = geometries;\n          (0,mobx__WEBPACK_IMPORTED_MODULE_18__.reaction)(function () {\n            return !!store.pointSetsUI.pointSets && store.pointSetsUI.pointSets.slice();\n          }, function (pointSets) {\n            if (!pointSets || pointSets.length === 0) {\n              return;\n            }\n            pointSets.forEach(function (pointSet, index) {\n              if (store.pointSetsUI.sources.length <= index) {\n                var uid = \"PointSetSource\".concat(index);\n                var pointSetSource = proxyManager.createProxy('Sources', 'TrivialProducer', {\n                  name: uid\n                });\n                store.pointSetsUI.sources.push(pointSetSource);\n                store.pointSetsUI.sources[index].setInputData(pointSet);\n                var pointSetRepresentationUid = \"pointSetRepresentation\".concat(index);\n                var pointSetRepresentation = proxyManager.createProxy('Representations', 'PointSet', {\n                  name: pointSetRepresentationUid\n                });\n                pointSetRepresentation.setInput(pointSetSource);\n                pointSetRepresentation.setRadiusFactor(store.pointSetsUI.lengthPixelRatio);\n                store.itkVtkView.addRepresentation(pointSetRepresentation);\n                store.pointSetsUI.representationProxies.push(pointSetRepresentation);\n                (0,_Rendering_VTKJS_Main_croppingPlanes__WEBPACK_IMPORTED_MODULE_17__.addCroppingPlanes)(context, pointSetRepresentation);\n              } else {\n                store.pointSetsUI.sources[index].setInputData(pointSet);\n                store.pointSetsUI.representationProxies[index].setVisibility(true);\n              }\n            });\n            (0,_Rendering_VTKJS_Main_croppingPlanes__WEBPACK_IMPORTED_MODULE_17__.updateCroppingParameters)(context);\n            if (pointSets.length < store.pointSetsUI.representationProxies.length) {\n              var proxiesToDisable = store.pointSetsUI.representationProxies.slice(pointSets.length);\n              proxiesToDisable.forEach(function (proxy) {\n                proxy.setVisibility(false);\n              });\n            }\n            if (!store.pointSetsUI.initialized) {\n              _UserInterface__WEBPACK_IMPORTED_MODULE_7__[\"default\"].createPointSetsUI(store, context.uiContainer);\n            }\n          });\n          store.pointSetsUI.pointSets = pointSets;\n          store.itkVtkView.resize();\n          // eslint-disable-next-line no-unused-vars\n          resizeSensor = new (css_element_queries_src_ResizeSensor__WEBPACK_IMPORTED_MODULE_5___default())(store.container, function () {\n            store.itkVtkView.resize();\n          });\n          proxyManager.renderAllViews();\n          setTimeout(function () {\n            store.itkVtkView.resetCamera();\n\n            // Estimate a reasonable point sphere radius in pixels\n            var lengthPixelRatio = store.itkVtkView.getLengthPixelRatio();\n            store.pointSetsUI.lengthPixelRatio = lengthPixelRatio;\n            store.pointSetsUI.representationProxies.forEach(function (proxy) {\n              proxy.setRadiusFactor(lengthPixelRatio);\n            });\n          }, 1);\n          _UserInterface__WEBPACK_IMPORTED_MODULE_7__[\"default\"].addLogo(store);\n          publicAPI.render = function () {\n            service.send('RENDER');\n          };\n\n          // The `store` is considered an internal implementation detail\n          // and its interface and behavior may change without changes to the major version.\n          publicAPI.getStore = function () {\n            return store;\n          };\n          publicAPI.setPointSets = function (pointSets) {\n            store.pointSetsUI.pointSets = pointSets;\n          };\n          publicAPI.setGeometries = function (geometries) {\n            store.geometriesUI.geometries = geometries;\n          };\n          eventNames = ['toggleUICollapsed', 'backgroundColorChanged', 'toggleFullscreen', 'toggleAnnotations', 'toggleAxes', 'toggleRotate', 'toggleCroppingPlanes', 'croppingPlanesChanged', 'resetCroppingPlanes', 'viewModeChanged', 'xSliceChanged', 'ySliceChanged', 'zSliceChanged', 'toggleLayerVisibility', 'imagePicked', 'imagePiecewiseFunctionGaussiansChanged', 'imagePiecewiseFunctionPointsChanged', 'imageVisualizedComponentChanged', 'toggleImageInterpolation', 'imageColorRangeChanged', 'imageColorRangeBoundsChanged', 'imageColorMapChanged', 'toggleImageShadow', 'imageGradientOpacityChanged', 'imageGradientOpacityScaleChanged', 'imageVolumeSampleDistanceChanged', 'imageBlendModeChanged', 'labelImageLookupTableChanged', 'labelImageBlendChanged', 'labelImageLabelNamesChanged', 'labelImageWeightsChanged', 'pointSetColorChanged', 'pointSetOpacityChanged', 'pointSetSizeChanged', 'pointSetRepresentationChanged', 'screenshotTaken'];\n          publicAPI.getEventNames = function () {\n            return eventNames;\n          };\n          publicAPI.on = function () {\n            return eventEmitter.on.apply(eventEmitter, arguments);\n          };\n          publicAPI.off = function () {\n            return eventEmitter.off.apply(eventEmitter, arguments);\n          };\n          publicAPI.once = function () {\n            return eventEmitter.once.apply(eventEmitter, arguments);\n          };\n          publicAPI.getEventEmitter = function () {\n            return eventEmitter;\n          };\n          publicAPI.getConfig = function () {\n            return context.getConfig();\n          };\n          publicAPI.setUICollapsed = function (collapse) {\n            if (collapse !== context.uiCollapsed) {\n              service.send('TOGGLE_UI_COLLAPSED');\n            }\n          };\n          publicAPI.getUICollapsed = function () {\n            return context.uiCollapsed;\n          };\n          publicAPI.setRenderingViewContainerStyle = function (containerStyle) {\n            service.send({\n              type: 'STYLE_RENDERING_VIEW_CONTAINER',\n              data: containerStyle\n            });\n          };\n          publicAPI.getRenderingViewContainerStyle = function () {\n            return _objectSpread({}, context.renderingViewContainerStyle);\n          };\n          (0,mobx__WEBPACK_IMPORTED_MODULE_18__.reaction)(function () {\n            return store.imageUI.lastPickedValues;\n          }, function () {\n            var lastPickedValues = store.imageUI.lastPickedValues;\n            eventEmitter.emit('imagePicked', (0,mobx__WEBPACK_IMPORTED_MODULE_18__.toJS)(lastPickedValues));\n          });\n          publicAPI.setBackgroundColor = function (bgColor) {\n            service.send({\n              type: 'SET_BACKGROUND_COLOR',\n              data: bgColor\n            });\n          };\n          publicAPI.getBackgroundColor = function () {\n            return context.main.backgroundColor.slice();\n          };\n          publicAPI.setUnits = function (units) {\n            service.send({\n              type: 'SET_UNITS',\n              data: units\n            });\n          };\n          publicAPI.getUnits = function () {\n            return context.main.units;\n          };\n\n          // Gaussians not supported\n          publicAPI.setImagePiecewiseFunctionGaussians = function (gaussians, component, name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            if (typeof component === 'undefined') {\n              component = 0;\n            }\n            service.send({\n              type: 'IMAGE_PIECEWISE_FUNCTION_GAUSSIANS_CHANGED',\n              data: {\n                name: name,\n                component: component,\n                gaussians: gaussians\n              }\n            });\n          };\n\n          // Gaussians not supported\n          publicAPI.getImagePiecewiseFunctionGaussians = function (component, name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            if (typeof component === 'undefined') {\n              component = 0;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            return actorContext.piecewiseFunctionGaussians.get(component);\n          };\n          publicAPI.setImagePiecewiseFunctionPoints = function (points, component, name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            if (typeof component === 'undefined') {\n              component = 0;\n            }\n            service.send({\n              type: 'IMAGE_PIECEWISE_FUNCTION_POINTS_CHANGED',\n              data: {\n                name: name,\n                component: component,\n                points: points\n              }\n            });\n          };\n          publicAPI.getImagePiecewiseFunctionPoints = function (component, name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            if (typeof component === 'undefined') {\n              component = 0;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            return actorContext.piecewiseFunctionPoints.get(component);\n          };\n\n          // Start collapsed on mobile devices or small pages\n          if (config && typeof config.uiCollapsed !== 'undefined' && window.screen.availWidth < 768 || window.screen.availHeight < 800) {\n            publicAPI.setUICollapsed(true);\n          }\n          publicAPI.captureImage = function () {\n            return store.itkVtkView.captureImage();\n          };\n          publicAPI.setAnnotationsEnabled = function (enabled) {\n            if (enabled !== context.main.annotationsEnabled) {\n              service.send('TOGGLE_ANNOTATIONS');\n            }\n          };\n          publicAPI.getAnnotationsEnabled = function () {\n            return context.main.annotationsEnabled;\n          };\n          publicAPI.setAxesEnabled = function (enabled) {\n            if (enabled !== context.main.axesEnabled) {\n              service.send('TOGGLE_AXES');\n            }\n          };\n          publicAPI.getAxesEnabled = function () {\n            return context.main.axesEnabled;\n          };\n          publicAPI.setRotateEnabled = function (enabled) {\n            if (enabled !== context.main.rotateEnabled) {\n              service.send('TOGGLE_ROTATE');\n            }\n          };\n          publicAPI.getRotateEnabled = function () {\n            return context.main.rotateEnabled;\n          };\n          publicAPI.setFullscreenEnabled = function (enabled) {\n            if (enabled !== context.main.fullscreenEnabled) {\n              service.send('TOGGLE_FULLSCREEN');\n            }\n          };\n          publicAPI.getFullscreenEnabled = function () {\n            return context.main.fullscreenEnabled;\n          };\n          publicAPI.setViewMode = function (mode) {\n            if (mode !== context.main.viewMode) {\n              service.send({\n                type: 'VIEW_MODE_CHANGED',\n                data: mode\n              });\n            }\n          };\n          publicAPI.getViewMode = function () {\n            return context.main.viewMode;\n          };\n          publicAPI.setXSlice = function (position) {\n            service.send({\n              type: 'X_SLICE_CHANGED',\n              data: position\n            });\n          };\n          publicAPI.getXSlice = function () {\n            return context.main.xSlice;\n          };\n          publicAPI.setYSlice = function (position) {\n            service.send({\n              type: 'Y_SLICE_CHANGED',\n              data: position\n            });\n          };\n          publicAPI.getYSlice = function () {\n            return context.main.ySlice;\n          };\n          publicAPI.setZSlice = function (position) {\n            service.send({\n              type: 'Z_SLICE_CHANGED',\n              data: position\n            });\n          };\n          publicAPI.getZSlice = function () {\n            return context.main.zSlice;\n          };\n          publicAPI.getLayerNames = function () {\n            return Array.from(context.layers.actorContext.keys());\n          };\n          publicAPI.setLayerVisibility = function (visible, name) {\n            var actorContext = context.layers.actorContext.get(name);\n            if (visible !== actorContext.visible) {\n              context.service.send({\n                type: 'TOGGLE_LAYER_VISIBILITY',\n                data: name\n              });\n            }\n          };\n          publicAPI.getLayerVisibility = function (name) {\n            return context.layers.actorContext.get(name).visible;\n          };\n          publicAPI.selectLayer = function (name) {\n            context.service.send({\n              type: 'SELECT_LAYER',\n              data: name\n            });\n          };\n\n          // A shared API queue lets setCompareImage wait for setImage.\n          // Otherwise imageActorContext setting events won't yet have a actor machine to receive them.\n          apiFunctionQueue = new p_queue__WEBPACK_IMPORTED_MODULE_19__[\"default\"]({\n            concurrency: 1\n          });\n          queueApi = function queueApi(funcToQueue) {\n            return function () {\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              return apiFunctionQueue.add(function () {\n                return funcToQueue.apply(void 0, args);\n              });\n            };\n          }; // Queueing setImage syncs the order setImage(s) are called with the order image actorContexts are created, no matter the data passed.\n          // Some images take longer with toMultiscaleSpatialImage, then get sent to state machine later, even if they were called with viewer.setImage first.\n          // The last added image is the context.image.selectedImage\n          publicAPI.setImage = queueApi( /*#__PURE__*/function () {\n            var _ref3 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__[\"default\"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(image, imageName) {\n              var _ref4, _ref5, _context$images;\n              var name, multiscaleImage, actorContext;\n              return _regeneratorRuntime().wrap(function _callee$(_context) {\n                while (1) switch (_context.prev = _context.next) {\n                  case 0:\n                    name = (_ref4 = (_ref5 = imageName !== null && imageName !== void 0 ? imageName : image.name) !== null && _ref5 !== void 0 ? _ref5 : (_context$images = context.images) === null || _context$images === void 0 ? void 0 : _context$images.selectedName) !== null && _ref4 !== void 0 ? _ref4 : 'Image';\n                    _context.next = 3;\n                    return (0,_IO_toMultiscaleSpatialImage__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(image, false, context.maxConcurrency);\n                  case 3:\n                    multiscaleImage = _context.sent;\n                    multiscaleImage.name = name;\n                    if (context.images.actorContext.has(name)) {\n                      actorContext = context.images.actorContext.get(name);\n                      actorContext.image = multiscaleImage;\n                      service.send({\n                        type: 'IMAGE_ASSIGNED',\n                        data: name\n                      });\n                    } else {\n                      service.send({\n                        type: 'ADD_IMAGE',\n                        data: multiscaleImage\n                      });\n                    }\n                  case 6:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }, _callee);\n            }));\n            return function (_x3, _x4) {\n              return _ref3.apply(this, arguments);\n            };\n          }());\n          publicAPI.getImage = function (name) {\n            if (typeof name === 'undefined' && context.images.selectedName) {\n              name = context.images.selectedName;\n            }\n            return context.images.actorContext.get(name).image;\n          };\n          publicAPI.getImageInterpolationEnabled = function (name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            return actorContext.interpolationEnabled;\n          };\n          publicAPI.setImageInterpolationEnabled = function (enabled, name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            var currentEnabled = publicAPI.getImageInterpolationEnabled(name);\n            if (enabled !== currentEnabled) {\n              service.send({\n                type: 'TOGGLE_IMAGE_INTERPOLATION',\n                data: name\n              });\n            }\n          };\n          publicAPI.setImageComponentVisibility = function (visibility, component, name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            service.send({\n              type: 'IMAGE_COMPONENT_VISIBILITY_CHANGED',\n              data: {\n                name: name,\n                component: component,\n                visibility: visibility\n              }\n            });\n          };\n          publicAPI.getImageComponentVisibility = function (component, name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            return actorContext.componentVisibilities[component];\n          };\n          publicAPI.setCroppingPlanesEnabled = function (enabled) {\n            if (enabled !== context.main.croppingPlanesEnabled) {\n              service.send('TOGGLE_CROPPING_PLANES');\n            }\n          };\n          publicAPI.getCroppingPlanesEnabled = function () {\n            return context.main.croppingPlanesEnabled;\n          };\n          publicAPI.resetCroppingPlanes = function () {\n            service.send('RESET_CROPPING_PLANES');\n          };\n          publicAPI.getCroppingPlanes = function () {\n            return context.main.croppingPlanes;\n          };\n          publicAPI.setCroppingPlanes = function (croppingPlanes) {\n            service.send({\n              type: 'CROPPING_PLANES_CHANGED',\n              data: croppingPlanes\n            });\n          };\n          publicAPI.setImageColorRange = function (range, component, name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            if (typeof component === 'undefined') {\n              component = 0;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            var currentRange = actorContext.colorRanges.get(component);\n            if (typeof currentRange !== 'undefined' || currentRange[0] !== range[0] || currentRange[1] !== range[1]) {\n              service.send({\n                type: 'IMAGE_COLOR_RANGE_CHANGED',\n                data: {\n                  name: name,\n                  component: component,\n                  range: range\n                }\n              });\n            }\n          };\n          publicAPI.getImageColorRange = function (component, name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            if (typeof component === 'undefined') {\n              component = 0;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            return actorContext.colorRanges.get(component);\n          };\n          publicAPI.setImageColorRangeMin = function (value, component, name) {\n            var selectedComponent = component !== null && component !== void 0 ? component : 0;\n            var selectedName = name !== null && name !== void 0 ? name : context.images.selectedName;\n            service.send({\n              type: 'IMAGE_COLOR_RANGE_MIN_CHANGED',\n              data: {\n                name: selectedName,\n                component: selectedComponent,\n                value: value\n              }\n            });\n          };\n          publicAPI.setImageColorRangeMax = function (value, component, name) {\n            var selectedComponent = component !== null && component !== void 0 ? component : 0;\n            var selectedName = name !== null && name !== void 0 ? name : context.images.selectedName;\n            service.send({\n              type: 'IMAGE_COLOR_RANGE_MAX_CHANGED',\n              data: {\n                name: selectedName,\n                component: selectedComponent,\n                value: value\n              }\n            });\n          };\n          publicAPI.setImageColorRangeBounds = function (range, component, name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            if (typeof component === 'undefined') {\n              component = 0;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            var currentRange = actorContext.colorRanges.get(component);\n            if (typeof currentRange !== 'undefined' || currentRange[0] !== range[0] || currentRange[1] !== range[1]) {\n              service.send({\n                type: 'IMAGE_COLOR_RANGE_BOUNDS_CHANGED',\n                data: {\n                  name: name,\n                  component: component,\n                  range: range\n                }\n              });\n            }\n          };\n          publicAPI.getImageColorRangeBounds = function (component, name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            if (typeof component === 'undefined') {\n              component = 0;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            return actorContext.colorRangeBounds.get(component);\n          };\n          publicAPI.setImageColorMap = function (colorMap, componentIndex, name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            if (typeof componentIndex === 'undefined') {\n              componentIndex = 0;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            var currentColorMap = actorContext.colorMaps.get(componentIndex);\n            if (typeof currentColorMap !== 'undefined' || currentColorMap[0] !== colorMap[0] || currentColorMap[1] !== colorMap[1]) {\n              service.send({\n                type: 'IMAGE_COLOR_MAP_CHANGED',\n                data: {\n                  name: name,\n                  component: componentIndex,\n                  colorMap: colorMap\n                }\n              });\n            }\n          };\n          publicAPI.getImageColorMap = function (componentIndex, name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            if (typeof componentIndex === 'undefined') {\n              componentIndex = 0;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            return actorContext.colorMaps.get(componentIndex);\n          };\n          publicAPI.setLabelImage = queueApi( /*#__PURE__*/function () {\n            var _ref6 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__[\"default\"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(labelImage, layerImageName) {\n              var _ref7;\n              var multiscaleLabelImage, imageName, actorContext;\n              return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                while (1) switch (_context2.prev = _context2.next) {\n                  case 0:\n                    _context2.next = 2;\n                    return (0,_IO_toMultiscaleSpatialImage__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(labelImage, true, context.maxConcurrency);\n                  case 2:\n                    multiscaleLabelImage = _context2.sent;\n                    if (multiscaleLabelImage.name === 'Image') {\n                      multiscaleLabelImage.name = 'LabelImage';\n                    }\n                    imageName = (_ref7 = layerImageName !== null && layerImageName !== void 0 ? layerImageName : context.images.selectedName) !== null && _ref7 !== void 0 ? _ref7 : multiscaleLabelImage.name;\n                    actorContext = context.images.actorContext.get(imageName);\n                    if ((actorContext === null || actorContext === void 0 ? void 0 : actorContext.labelImageName) === multiscaleLabelImage.name) {\n                      actorContext.labelImage = multiscaleLabelImage;\n                      service.send({\n                        type: 'LABEL_IMAGE_ASSIGNED',\n                        data: imageName\n                      });\n                    } else {\n                      service.send({\n                        type: 'ADD_LABEL_IMAGE',\n                        data: {\n                          imageName: imageName,\n                          labelImage: multiscaleLabelImage\n                        }\n                      });\n                    }\n                    publicAPI.setImageInterpolationEnabled(false, imageName);\n                  case 8:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }, _callee2);\n            }));\n            return function (_x5, _x6) {\n              return _ref6.apply(this, arguments);\n            };\n          }());\n          publicAPI.getLabelImage = function () {\n            var name = context.images.selectedName;\n            return context.images.actorContext.get(name).labelImage;\n          };\n          publicAPI.setLabelImageLookupTable = function (lookupTable, name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            var currentLookupTable = actorContext.lookupTable;\n            if (currentLookupTable !== lookupTable) {\n              service.send({\n                type: 'LABEL_IMAGE_LOOKUP_TABLE_CHANGED',\n                data: {\n                  name: name,\n                  lookupTable: lookupTable\n                }\n              });\n            }\n          };\n          publicAPI.getLabelImageLookupTable = function (name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            return actorContext.lookupTable;\n          };\n          publicAPI.setLabelImageBlend = function (blend, name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            var currentBlend = actorContext.labelImageBlend;\n            if (currentBlend !== blend) {\n              service.send({\n                type: 'LABEL_IMAGE_BLEND_CHANGED',\n                data: {\n                  name: name,\n                  labelImageBlend: blend\n                }\n              });\n            }\n          };\n          publicAPI.getLabelImageBlend = function (name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            return actorContext.labelImageBlend;\n          };\n          publicAPI.setLabelImageLabelNames = function (names, name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            var currentLabelNames = actorContext.labelNames;\n            if (currentLabelNames !== names) {\n              service.send({\n                type: 'LABEL_IMAGE_LABEL_NAMES_CHANGED',\n                data: {\n                  name: name,\n                  labelNames: names\n                }\n              });\n            }\n          };\n          publicAPI.getLabelImageLabelNames = function (name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            return actorContext.labelNames;\n          };\n          publicAPI.setLabelImageWeights = function (weights, name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            var currentWeights = actorContext.labelImageWeights;\n            if (currentWeights !== weights) {\n              service.send({\n                type: 'LABEL_IMAGE_WEIGHTS_CHANGED',\n                data: {\n                  name: name,\n                  labelImageWeights: weights\n                }\n              });\n            }\n          };\n          publicAPI.getLabelImageWeights = function (name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            return actorContext.labelImageWeights;\n          };\n\n          // Moving image must have been added last.\n          // See index.md for parameter docs.\n          publicAPI.setCompareImages = queueApi( /*#__PURE__*/function () {\n            var _ref8 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__[\"default\"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(fixedImageName, movingImageName, options) {\n              return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                while (1) switch (_context3.prev = _context3.next) {\n                  case 0:\n                    service.send({\n                      type: 'COMPARE_IMAGES',\n                      data: {\n                        name: movingImageName,\n                        fixedImageName: fixedImageName,\n                        options: options\n                      }\n                    });\n                  case 1:\n                  case \"end\":\n                    return _context3.stop();\n                }\n              }, _callee3);\n            }));\n            return function (_x7, _x8, _x9) {\n              return _ref8.apply(this, arguments);\n            };\n          }());\n          publicAPI.getCompareImages = function (name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            return context.images.actorContext.get(name).compare;\n          };\n          publicAPI.setImageShadowEnabled = function (enabled, name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            if (enabled !== actorContext.shadowEnabled) {\n              service.send({\n                type: 'TOGGLE_IMAGE_SHADOW',\n                data: name\n              });\n            }\n          };\n          publicAPI.getImageShadowEnabled = function (name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            return actorContext.shadowEnabled;\n          };\n          publicAPI.setImageGradientOpacity = function (opacity, name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            service.send({\n              type: 'IMAGE_GRADIENT_OPACITY_CHANGED',\n              data: {\n                name: name,\n                gradientOpacity: opacity\n              }\n            });\n          };\n          publicAPI.getImageGradientOpacity = function (name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            return actorContext.gradientOpacity;\n          };\n          publicAPI.setImageGradientOpacityScale = function (min, name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            service.send({\n              type: 'IMAGE_GRADIENT_OPACITY_SCALE_CHANGED',\n              data: {\n                name: name,\n                gradientOpacityScale: min\n              }\n            });\n          };\n          publicAPI.getImageGradientOpacityScale = function (name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            return actorContext.gradientOpacityScale;\n          };\n          publicAPI.setImageVolumeSampleDistance = function (distance, name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            service.send({\n              type: 'IMAGE_VOLUME_SAMPLE_DISTANCE_CHANGED',\n              data: {\n                name: name,\n                volumeSampleDistance: distance\n              }\n            });\n          };\n          publicAPI.getImageVolumeSampleDistance = function (name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            return actorContext.volumeSampleDistance;\n          };\n          publicAPI.setImageBlendMode = function (mode, name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            service.send({\n              type: 'IMAGE_BLEND_MODE_CHANGED',\n              data: {\n                name: name,\n                blendMode: mode\n              }\n            });\n          };\n          publicAPI.getImageBlendMode = function (name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            return actorContext.blendMode;\n          };\n          publicAPI.addPointSet = function (pointSet) {\n            if (!store.pointSetsUI.pointSets) {\n              store.pointSetsUI.pointSets = [];\n            }\n            store.pointSetsUI.pointSets.push(pointSet);\n          };\n          (0,mobx__WEBPACK_IMPORTED_MODULE_18__.reaction)(function () {\n            return store.pointSetsUI.colors.slice();\n          }, function (colors) {\n            var selectedPointSetIndex = store.pointSetsUI.selectedPointSetIndex;\n            var color = colors[selectedPointSetIndex];\n            eventEmitter.emit('pointSetColorChanged', selectedPointSetIndex, color);\n          });\n          publicAPI.setPointSetColor = function (index, rgbColor) {\n            var hexColor = (0,_UserInterface_rgb2hex__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(rgbColor);\n            if (index < store.pointSetsUI.colors.length) {\n              store.pointSetsUI.colors[index] = hexColor;\n            }\n          };\n          publicAPI.getPointSetColor = function (index) {\n            var hexColor = store.pointSetsUI.colors[index];\n            var rgbColor = (0,_UserInterface_hex2rgb__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(hexColor);\n            return rgbColor;\n          };\n          (0,mobx__WEBPACK_IMPORTED_MODULE_18__.reaction)(function () {\n            return store.pointSetsUI.opacities.slice();\n          }, function (opacities) {\n            var selectedPointSetIndex = store.pointSetsUI.selectedPointSetIndex;\n            var opacity = opacities[selectedPointSetIndex];\n            eventEmitter.emit('pointSetOpacityChanged', selectedPointSetIndex, opacity);\n          });\n          publicAPI.setPointSetOpacity = function (index, opacity) {\n            if (index < store.pointSetsUI.opacities.length) {\n              store.pointSetsUI.opacities[index] = opacity;\n            }\n          };\n          publicAPI.getPointSetOpacity = function (index) {\n            return store.pointSetsUI.opacities[index];\n          };\n          (0,mobx__WEBPACK_IMPORTED_MODULE_18__.reaction)(function () {\n            return store.pointSetsUI.sizes.slice();\n          }, function (sizes) {\n            var selectedPointSetIndex = store.pointSetsUI.selectedPointSetIndex;\n            var size = sizes[selectedPointSetIndex];\n            eventEmitter.emit('pointSetSizeChanged', selectedPointSetIndex, size);\n          });\n          publicAPI.setPointSetSize = function (index, size) {\n            if (index < store.pointSetsUI.sizes.length) {\n              store.pointSetsUI.sizes[index] = size;\n            }\n          };\n          publicAPI.getPointSetSize = function (index) {\n            return store.pointSetsUI.sizes[index];\n          };\n          (0,mobx__WEBPACK_IMPORTED_MODULE_18__.reaction)(function () {\n            return store.pointSetsUI.representations.slice();\n          }, function (representations) {\n            var selectedPointSetIndex = store.pointSetsUI.selectedPointSetIndex;\n            var representation = representations[selectedPointSetIndex];\n            eventEmitter.emit('pointSetRepresentationChanged', selectedPointSetIndex, representation);\n          });\n          publicAPI.setPointSetRepresentation = function (index, representation) {\n            if (index < store.pointSetsUI.representations.length) {\n              store.pointSetsUI.representations[index] = representation;\n            }\n          };\n          publicAPI.setGeometryColor = function (index, rgbColor) {\n            var hexColor = (0,_UserInterface_rgb2hex__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(rgbColor);\n            store.geometriesUI.colors[index] = hexColor;\n          };\n          publicAPI.setGeometryOpacity = function (index, opacity) {\n            store.geometriesUI.opacities[index] = opacity;\n          };\n          publicAPI.setImageScale = function (targetScale) {\n            service.send({\n              type: 'SET_IMAGE_SCALE',\n              targetScale: targetScale\n            });\n          };\n\n          // The `itkVtkView` is considered an internal implementation detail\n          // and its interface and behavior may change without changes to the major version.\n          publicAPI.getViewProxy = function () {\n            return store.itkVtkView;\n          };\n          publicAPI.setImageVolumeScatteringBlend = function (scatteringBlend, name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            service.send({\n              type: 'SET_CINEMATIC_PARAMETERS',\n              data: {\n                name: context.images.selectedName,\n                params: {\n                  scatteringBlend: scatteringBlend\n                }\n              }\n            });\n          };\n          publicAPI.getImageVolumeScatteringBlend = function (name) {\n            if (typeof name === 'undefined') {\n              name = context.images.selectedName;\n            }\n            var actorContext = context.images.actorContext.get(name);\n            return actorContext.cinematicParameters.scatteringBlend;\n          };\n          publicAPI.setMaxConcurrency = function (value) {\n            context.maxConcurrency = value;\n          };\n          publicAPI.getMaxConcurrency = function () {\n            return context.maxConcurrency;\n          };\n          publicAPI.getLoadedScale = function (name) {\n            var imageName = name !== null && name !== void 0 ? name : context.images.selectedName;\n            var actorContext = context.images.actorContext.get(imageName);\n            return actorContext.loadedScale;\n          };\n          publicAPI.getCroppedImageWorldBounds = function () {\n            return (0,_Rendering_VTKJS_Main_croppingPlanes__WEBPACK_IMPORTED_MODULE_17__.getCropWidgetBounds)(context);\n          };\n          publicAPI.getCroppedIndexBounds = /*#__PURE__*/function () {\n            var _ref9 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__[\"default\"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(scale, name) {\n              var imageName, actorContext, image, bounds, indexToWorld, fullIndexBounds;\n              return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                while (1) switch (_context4.prev = _context4.next) {\n                  case 0:\n                    imageName = name !== null && name !== void 0 ? name : context.images.selectedName;\n                    actorContext = context.images.actorContext.get(imageName);\n                    if (typeof scale === 'undefined' || scale < 0) {\n                      scale = actorContext.loadedScale;\n                    }\n                    image = actorContext.image;\n                    bounds = (0,_Rendering_VTKJS_Main_croppingPlanes__WEBPACK_IMPORTED_MODULE_17__.getCropWidgetBounds)(context);\n                    _context4.next = 7;\n                    return image.scaleIndexToWorld(scale);\n                  case 7:\n                    indexToWorld = _context4.sent;\n                    fullIndexBounds = image.getIndexBounds(scale);\n                    return _context4.abrupt(\"return\", (0,_IO_MultiscaleSpatialImage__WEBPACK_IMPORTED_MODULE_13__.worldBoundsToIndexBounds)({\n                      bounds: bounds,\n                      fullIndexBounds: fullIndexBounds,\n                      worldToIndex: gl_matrix__WEBPACK_IMPORTED_MODULE_22__.invert([], indexToWorld)\n                    }));\n                  case 10:\n                  case \"end\":\n                    return _context4.stop();\n                }\n              }, _callee4);\n            }));\n            return function (_x10, _x11) {\n              return _ref9.apply(this, arguments);\n            };\n          }();\n          (0,_UI_addKeyboardShortcuts__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(context.uiContainer, service);\n\n          // must come before moving/main image\n          if (!fixedImage) {\n            _context5.next = 173;\n            break;\n          }\n          _context5.next = 173;\n          return publicAPI.setImage(fixedImage, 'Fixed');\n        case 173:\n          if (!imageMultiscale) {\n            _context5.next = 176;\n            break;\n          }\n          _context5.next = 176;\n          return publicAPI.setImage(imageMultiscale, imageName);\n        case 176:\n          if (labelImageMultiscale) {\n            publicAPI.setLabelImage(labelImageMultiscale, imageMultiscale === null || imageMultiscale === void 0 ? void 0 : imageMultiscale.name);\n          }\n          if (fixedImage && imageMultiscale) {\n            publicAPI.setCompareImages('Fixed', imageMultiscale.name, compare);\n          }\n          if (!context.use2D) {\n            publicAPI.setRotateEnabled(rotate);\n          }\n\n          // check with isNaN as may be 0\n          if (!isNaN(gradientOpacity)) {\n            publicAPI.setImageGradientOpacity(gradientOpacity);\n          }\n          return _context5.abrupt(\"return\", publicAPI);\n        case 181:\n        case \"end\":\n          return _context5.stop();\n      }\n    }, _callee5);\n  }));\n  return function createViewer(_x, _x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createViewer);\n\n//# sourceURL=webpack://itkVtkViewer/./src/createViewer.js?");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/get javascript chunk filename */
/******/ (() => {
/******/ 	// This function allow to reference async chunks
/******/ 	__webpack_require__.u = (chunkId) => {
/******/ 		// return url for filenames based on template
/******/ 		return "" + chunkId + ".itkVtkViewerCDN.js";
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/get javascript update chunk filename */
/******/ (() => {
/******/ 	// This function allow to reference all chunks
/******/ 	__webpack_require__.hu = (chunkId) => {
/******/ 		// return url for filenames based on template
/******/ 		return "" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("c3e7c143539733e7c312")
/******/ })();
/******/ 
/******/ }
);